\section{Генериране на графа}

\paragraph*{} Решението на задачата може да се раздели на две независими части - генерирането на графа и обхождането му. Графа се запазва в списъци на съседство, защото реших, че това ще е най-удачно откъм необходима памет.

\subsection{Ориентиран граф}

\paragraph*{} Генерирането на ориентиран граф е лесна задача за разпареляване ако се използва принципа паралелизъм по данни. Изпробвани два подхода:

\begin{itemize}
\item Ако разполагаме с $t$ на брой нишки, то разделяме върховете на графа на $n \over t$ равни части и във всяка част генерираме $m \over t$ ребра. Всяка нишка работи върху отделна част от графа.
\item Разделяме графа на части с фиксирана големина от $K$ върхове и $m \over K$ ребра. Частите се добавят като задачи в опашка и thread pool-а се грижи за разпределянето им по наличните нишки. В кода за стойност на $K$ е използвано 128.
\end{itemize}

\paragraph*{} Двата подхода са разгледани главно за да се сравни ръчното разпределяне на задачата (първи подход) с автоматичното разпределяне предоставяно от rayon (втори подход).

\subsection{Неориентиран граф}

\paragraph*{} Генерирането на неориентиран граф е по-сложна задача, защото за всяко добавено ребро \textit{(u, v)}, трябва да се добави и обратното ребро \textit{(v, u)}. Това не би било проблем ако се използваше матрица на съседство, но решението графа да се запазва в списъци на съседство усложнява проблема.

\paragraph*{} Първата стъпка е да се генерират ребрата \textit{(u, v)} така, че \textit{u > v}. Използва се втория подход като при ориентирания граф, с разликата, че броят ребра, които се генерират за часта с върхове от $a$ до $b$ е $m * (b^2 - a^2) \over n^2$.

\paragraph*{} След това трябва да се добавят огледалните ребра. За това е нужен конкурентен достъп до структурата. Ако в даден момент се опитваме едновременно да обходим ребрата \textit{(a, $v_i$)} и да добавим реброто \textit{(a, b)} ще има конфликт между четец и писател за вектора \verb|lists[a]|. Аналогично ако се опитаме да добавим ребра \textit{(a, b)} и \textit{(a, c)} ще имаме конфликт между два писателя. Възможни решения са:

\begin{itemize}
\item Добавянето на огледални ребра се реализира последователно, използвайки само една нишка.
\item Използва се механизъм за заключване, като отделните вектори се заключват поотделно. Изпробвано е с mutex на операционната система и spin lock. Добре е да се отбележи, че оригиналните ребра са от вида \textit{(u, v)}, където \textit{u > v}, поради което е невъзможно да се получи deadlock.
\item Използва се допълнителна lock-free структура от данни, например опашка, към всеки вектор, в която се записват върховете които трябва да се добавят. След обхождането върховете могат да се добавят без проблем. За съжаление този подход не е тестван поради бъг в имплементацията :(.
\end{itemize}
