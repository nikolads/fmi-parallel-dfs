\section{Генериране на графа}

\paragraph*{} Решението на задачата може да се раздели на две независими части - генерирането на графа и обхождането му. Реализирани са два варианта за записване на графа - като списъци на съседство и като матрица на съседство.

\subsection{Списъци на съседство}

\paragraph*{} Списъците на съседство са в общия случай по-бързи за генериране и обработка и заемат по-малко памет от матрицата, но не позволяват много добро разпареляване при генерирането на неориентиран граф.

\paragraph*{Ориентиран граф} За генерирането на ориентиран граф се използва следната стратегия. Графа се разделя на множество части, всяка с фиксиран размер от $k$ върха (k = 128) и $m * {n \over k}$ ребра. За всяка част се пуска задача в глобален thread pool, като часта с върхове \textit{a..b} генерира ребра започващи от нея, т.е. ребра \textit{(c, v)}, $a <= c <= b$. Така всяка нишка работи върху отделна част от графа.

\paragraph*{Неориентиран граф} Генерирането на неориентиран граф е по-сложна задача, защото за всяко добавено ребро \textit{(u, v)}, трябва да се добави и обратното ребро \textit{(v, u)}. Първата стъпка е да се генерират ребрата \textit{(u, v)} така, че \textit{u > v}. Използва се същия подход като при ориентирания граф, с разликата, че броят ребра, които се генерират за часта с върхове от $a$ до $b$ е $m * (b^2 - a^2) \over n^2$.

\paragraph*{} След това трябва да се добавят огледалните ребра. Идеята е да обходим вече генерираните ребра, и за всяко ребро \textit{(a, b)} да добавим реброто \textit{(b, a)}. Ако се опитаме да направим това паралелно трябва да се добави синхронизация, защото може да се срещнат две ребра \textit{(a, b)} и \textit{(c, b)} едновременно, при което се получава едновременно писане в вектора \textit{b}.

\paragraph*{} Пробвани са няколко подхода
\begin{itemize}
\item Последователен алгоритъм - използвайки само една нишка, няма нужда от синхронизация.
\item Векторите се заключват поотделно. Изпробвано е с ОС mutex и spin lock.
\item Използва се допълнителна lock-free структура от данни към всеки вектор, в която се записват върховете които трябва да се добавят. След обхождането те могат да се добавят паралелно без проблем
\end{itemize}

\paragraph*{} След тестване най-бързо се оказа последователния алгоритъм, затова се използва той.

\subsection{Матрица на съседство}

\paragraph*{} При матрицата на съседство разпареляването на алгоритъма е лесно и в двата случая

\paragraph*{Ориентиран граф} Разделяме задачата на подзадачи, като всяка подзадача генерира фиксиран брой ребра. Подзадачите се изпълняват едновременно от thread pool. Всяка подзадача генерира случайно ребро \textit{(u, v)} и го записва в матрицата и проверява дали вече съществува с една атомарна операция. Това продължава докато не се генерират 128 ребра.

\paragraph*{Неoриентиран граф} Идеята е същата като при ориентирания, с изключението че се генерират само ребра за които \textit{u < v}. Нишката пробва да добави реброто \textit{(u, v)}. Ако това успее, то реброто \textit{(v, u)} също не съществува и никой друг няма да се опита да го добави, затова нишката го добавя и него.

\subsection{Резултати}

\paragraph*{Списъци на съседство - ориентиран граф}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{Списъци на съседство - неориентиран граф}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{Матрица на съседство - ориентиран граф}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{Матрица на съседство - неориентиран граф}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}
