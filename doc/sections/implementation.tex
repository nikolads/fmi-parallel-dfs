\section{Реализация}

\paragraph*{} Проектът е реализиран като приложение за командния ред. Поддържа се следния интерфейс

\verb|./parallel_dfs gen -n 20 -m 40 -t 4 --algo par_mat|

\begin{itemize}
\item \verb|gen| - режим на работа. Единственият имплементиран е gen - генерирай случаен граф и направи обхождане по него.
\item \verb|-n 20| - брой върхове
\item \verb|-m 40| - брой ребра
\item \verb|-t 4| - колко нишки да използва
\item \verb|--algo par_mat| - кои алгоритми и стуктури от данни да използва. Вариантите са \verb|seq_list|, \verb|par_list|, \verb|cheat_list|, \verb|seq_mat|, \verb|par_mat|, \verb|cheat_mat|
\end{itemize}

Всички аргументи могат да се видят с \verb|./parallel_dfs --help|

\paragraph*{} Следните изисквания към проекта не са имплементирани:
\begin{itemize}
\item въвеждане на граф от входен файл
\item извеждане на резултата в изходен файл (има опция за извеждане на резултата на стандартния изход в "debug" формат).
\end{itemize}

\paragraph*{} Използван е езикът Rust. Използвани са няколко външни библиотеки за различни детайли, но по-основно е използвана библиотеката rayon. Rayon e библиотека която цели да предостави удобен интерфейс за паралелна обработка на данни. (\textit{Забележка} - една от причините да използвам rayon е че покрай този проект исках да разгледам какви възможности дава библиотеката. Другата е, че rayon имаше най-бързата имплементация на thread pool, която успях да намеря).

\paragraph*{} Rayon работи с глобален thread pool към който се добавят задачи. В този проект са използвани главно два начина за създаване на задачи:
\begin{itemize}
\item \verb|rayon::scope()| - създава "блок", от който могат да се пускат задачи в глобалния thread pool със \verb|scope.spawn(fn)|. След края на блока се блокира докато всички пуснати от него задачи не приключат.
\item паралелни итератори - \verb|collection.par_iter().for_each(fn)|. Извиква fn върху всеки елемент от коленцията паралелно. Вътрешно се опитва да раздели колекцията на няколко части, така че всяка нишка да работи върху отделна част. Отново самото изпълнение се случва в thread pool-а.
\end{itemize}
