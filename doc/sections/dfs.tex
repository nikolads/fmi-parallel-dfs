\section{Обхождане на графа}

\subsection{Алгоритми}

\paragraph*{} Резултатът от обхождането на графа е гора от дървета, като всяко дърво е представено като корен и списък от наредени двойки \textit{(родител, дете)}. Списъкът е сортиран в реда в който DFS алгоритъмът е намерил съответното дете. Може да има повече от едно дърво ако графът не е свързан. Имплементирани са три различни DFS алгоритъма.

\paragraph*{Seq} Стандартен еднонишков dfs алгоритъм. Използва се за база за сравнение.

\paragraph*{Cheat} Взима $t$ на брой случайни върха, по един за всяка нишка, и пуска dfs от всеки от тях. Използва се споделен масив за проверка на това кои върхове са обходени. Първата нишка, която намери връх го маркира за обходен. Ако нишка види обходен връх тя го игнорира. Резултатът от алгоритъма се различава от това което стандартния еднонишков варант би върнал, но за сметка на това се печели скорост.

\paragraph*{Par} Пуска се еднонишков dfs алгоритъм, който изпълнява само "спускането". Ако в момента сме във връх $u$  то се преминава към първото необходено дете на $u$. Ако $u$ няма необходени деца, алгоритъма спира. Резултатът от това е стек с всички намерени по време на спускането върхове. Следващата стъпка е връщането назад (backtracking) - при което трябва да се проверят и останалите необходени деца (след първото) на елементите в стека. Тази стъпка се изпълнява паралелно. За всеки елемент от стека се създава подзадача, която изпълнява нормален (пълен) dfs започвайки от този връх. Задачите се добавят в thread pool.

\paragraph*{} Така пуснатите задачи все още могат да намерят едни и същи върхове. Затова всеки пуснат dfs има цифров приоритет, като dfs-ите с елементи от началото на стека имат по-голям приоритет. Пази се споделен масив, в който за всеки намерен връх се записва приоритета, с който е намерен. Когато една нишка намери връх, тя проверява в масива с приоритетите. Ако този елемент вече съществува с по-голям приоритет, той се смята за обходен и се игнорира. Ако не съществува или има по-малък приоритет, то приоритета се презаписва с по-големия и обхождането продължава.

\paragraph*{} След приключване на втората стъпка имаме отделни дървета от всяка под-задача. Последната стъпка включва премахване на елементи, които са били обходени повече от веднъж от всички дървета освен това с най-голям приоритет и обединяването на всички дървета в едно. Времето за тези операции е незначително спрямо по-горните стъпки.

\paragraph*{} Този алгоритъм връща същия резултат като еднонишков dfs.

\subsection{Резултати}

\paragraph*{par - списъци на съседство}

\begin{center}
\begin{tabular}{ c c c c c c }
  нишки & време(сек) & спускане & връщане & $S_p$ & $E_p$ \\
  seq & 1 & - & - & 1 & 1 \\
  1 & 2 & 0 & 0 & 0 & 0 \\
  2 & 3 & 0 & 0 & 0 & 0 \\
  3 & 3 & 0 & 0 & 0 & 0 \\
  4 & 3 & 0 & 0 & 0 & 0 \\
  6 & 3 & 0 & 0 & 0 & 0 \\
  8 & 3 & 0 & 0 & 0 & 0 \\
  10 & 3 & 0 & 0 & 0 & 0 \\
  12 & 3 & 0 & 0 & 0 & 0 \\
  14 & 3 & 0 & 0 & 0 & 0 \\
  16 & 3 & 0 & 0 & 0 & 0 \\
  20 & 3 & 0 & 0 & 0 & 0 \\
  24 & 3 & 0 & 0 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{par - матрица на съседство}

\begin{center}
\begin{tabular}{ c c c c c c }
  нишки & време(сек) & спускане & връщане & $S_p$ & $E_p$ \\
  seq & 1 & - & - & 1 & 1 \\
  1 & 2 & 0 & 0 & 0 & 0 \\
  2 & 3 & 0 & 0 & 0 & 0 \\
  3 & 3 & 0 & 0 & 0 & 0 \\
  4 & 3 & 0 & 0 & 0 & 0 \\
  6 & 3 & 0 & 0 & 0 & 0 \\
  8 & 3 & 0 & 0 & 0 & 0 \\
  10 & 3 & 0 & 0 & 0 & 0 \\
  12 & 3 & 0 & 0 & 0 & 0 \\
  14 & 3 & 0 & 0 & 0 & 0 \\
  16 & 3 & 0 & 0 & 0 & 0 \\
  20 & 3 & 0 & 0 & 0 & 0 \\
  24 & 3 & 0 & 0 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{cheat - списъци на съседство}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}

\paragraph*{cheat - матрица на съседство}

\begin{center}
\begin{tabular}{ c c c c }
  нишки & време(сек) & $S_p$ & $E_p$ \\
  seq & 1 & 1 & 1 \\
  1 & 2 & 0 & 0 \\
  2 & 3 & 0 & 0 \\
  3 & 3 & 0 & 0 \\
  4 & 3 & 0 & 0 \\
  6 & 3 & 0 & 0 \\
  8 & 3 & 0 & 0 \\
  10 & 3 & 0 & 0 \\
  12 & 3 & 0 & 0 \\
  14 & 3 & 0 & 0 \\
  16 & 3 & 0 & 0 \\
  20 & 3 & 0 & 0 \\
  24 & 3 & 0 & 0 \\
\end{tabular}
\end{center}
